package printer

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/viphxin/xingo/builder/parse"
	"golang.org/x/tools/imports"
)

type Module uint8

const (
	Api Module = 1 << iota
	Pool
	Rpc
)

type Printer struct {
	as *parse.ApiSet
	rs *parse.RpcSet

	fixImptSlc []fixImpt
}

type fixImpt struct {
	*os.File
	path string
}

func NewPrinter(moduleSlc ...interface{}) *Printer {
	p := &Printer{
		fixImptSlc: make([]fixImpt, 0),
	}

	for _, module := range moduleSlc {
		switch mod := module.(type) {
		case *parse.ApiSet:
			p.as = mod
		case *parse.RpcSet:
			p.rs = mod
		}
	}

	return p
}

func (p *Printer) Run() {
	buff := bytes.NewBuffer(nil)
	if p.as != nil {
		//pool
		pool(buff).Execute(p)
		if buff.Len() > 0 {
			poolPath := filepath.Join(filepath.Dir(p.as.OutPath), "pool/pool.go")
			p.createAndWrite(buff.Bytes(), poolPath)
		}

		buff.Reset()
		api(buff).Execute(p)
		p.createAndWrite(buff.Bytes(), p.as.OutPath)
	}

	if p.rs != nil {
		buff.Reset()
		rpc(buff).Execute(p)
		p.createAndWrite(buff.Bytes(), p.rs.OutPath)
	}

	p.fixImports()
}

func mkdirNotExist(dir string) error {
	if info, err := os.Stat(dir); err == nil {
		if info.IsDir() {
			return nil
		} else {
			return fmt.Errorf("cannot create directory `%s': File exists", dir)
		}
	} else if err != os.ErrNotExist && !strings.Contains(err.Error(), "no such file or directory") {
		return fmt.Errorf("cannot create directory `%s': %v", dir, err)
	} else {
		return os.MkdirAll(dir, 0775)
	}
}

func (p *Printer) createAndWrite(data []byte, path string) {
	dir := filepath.Dir(path)
	if err := mkdirNotExist(dir); err != nil {
		log.Printf("mkdir %s fail, err: %v\n", dir, err)
		return
	}

	file, err := os.OpenFile(path, os.O_RDWR|os.O_TRUNC|os.O_CREATE, 0664)
	if err != nil {
		log.Printf("os.OpenFile(%s) fail, err: %v\n", path, err)
		return
	} else {
		p.fixImptSlc = append(p.fixImptSlc, fixImpt{file, path})

		fdata := append([]byte("//Code generated by github.com/viphxin/xingo/builder DO NOT EDIT.\n\n"), data...)
		file.Write(fdata)
		file.Sync()
	}
}

func (p *Printer) fixImports() {
	for _, file := range p.fixImptSlc {
		defer file.Close()

		file.Seek(0, 0)
		src, err := ioutil.ReadAll(file)
		if err != nil {
			log.Printf("ioutil.ReadAll(%s) fail, err: %v\n", file.path, err)
			continue
		}

		if fix, err := imports.Process(file.path, src, nil); err != nil {
			log.Printf("imports.Process(%s) fail, err: %v\n", file.path, err)
			continue
		} else {
			file.Seek(0, 0)
			file.Truncate(0)
			file.Write(fix)
		}
	}
}
